; Based on CPSC 110 (@assignment bank/compound-l3) - "cowabunga-v6.rkt"
; https://cs110.students.cs.ubc.ca/bank/

; https://www.cs.utexas.edu/users/moore/acl2/manuals/current/manual/index-seo.php/ACL2____CGEN
(include-book "acl2s/cgen/top" :dir :system :ttags :all) ; Import CGEN
(acl2s-defaults :set testing-enabled t)                  ; Enable counter examples

; In CPSC 110 we had:
;; (define-struct cow (x dx))
;; Cow is (make-cow Natural Integer)
; Try to mimick this in ACL2

(defun make-cow (x dx)
  (list x dx))

(defun cow-x (cow)
  (first cow))

(defun cow-dx (cow)
  (second cow))

; Move cow position x by cow's dx. 
; 1.  We should always have that 0 <= cow x <= WIDTH
; 2.  Cow should always move dx distance when 0 <= x + dx <= WIDTH
; 3.  If x + dx < 0 or x + dx > WIDTH, the cow should flip directions (dx = -dx)

(defun move-cow (c WIDTH) ; Note: CPSC 110 move-cow had WIDTH as a global variable
  (cond ((> (+ (cow-x c) (cow-dx c)) WIDTH) (make-cow WIDTH (- (cow-dx c))))
        ((< (+ (cow-x c) (cow-dx c)) 0)     (make-cow 0     (- (cow-dx c))))
        (T (make-cow (+ (cow-x c) (cow-dx c))
                     (cow-dx c)))))

; Helper function to make sure 0 <= cow x <= WIDTH
(defun cow-in-bounds (c WIDTH)
  (and (>= (cow-x c) 0)   
       (<= (cow-x c) WIDTH)))

; Prove 1. (Generated by Gemini Advanced)
(defthm cow-always-stays-in-bounds 
  (implies  
   (and 
    ;(integerp (cow-x cow))   ; Cow's x-position is an integer
    ;(integerp WIDTH)         ; WIDTH is an integer
    ;(>= WIDTH 0)             ; WIDTH is non-negative 
    (>= (cow-x cow) 0)       ; Cow starts within bounds
    (<= (cow-x cow) WIDTH))  ; Cow remains within bounds
   (cow-in-bounds (move-cow cow WIDTH) WIDTH))) 

; Prove 2. Cow always move dx distance when possible
(defthm cow-moves-dx-within-boundaries
  (implies
   (and 
        ;(rationalp WIDTH)
        (>= (+ (cow-x cow) (cow-dx cow)) 0)       ; Cow ends within bounds
        (<= (+ (cow-x cow) (cow-dx cow)) WIDTH))
   (equal (cow-x (move-cow cow WIDTH))
          (+ (cow-x cow) (cow-dx cow)))))
; Notes: Changing the cond in move-cow to be >= causes the above theorem to fail if WIDTH is not a number


; Prove 3
(defthm cow-flips-direction-past-boundaries
  (implies
    (or
     (< (+ (cow-x cow) (cow-dx cow)) 0)
     (> (+ (cow-x cow) (cow-dx cow)) WIDTH))
  (equal (cow-dx (move-cow cow WIDTH))
         (- (cow-dx cow)))))#|ACL2s-ToDo-Line|#


; Notes: It's interesting to see what changes we can make to move-cow such that the proof fails
;        I also made several mistakes when defining theorems such that the wrong thing was proved